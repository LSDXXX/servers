package handlergen

const (
	NotEditMarkTemplate = `
// Code generated by handlergen DO NOT EDIT.
// Code generated by handlergen DO NOT EDIT.
// Code generated by handlergen DO NOT EDIT.
	`

	ImportHeaderTemplate = `
package {{.Package}}
import (
	"github.com/gin-gonic/gin"

	"github.com/LSDXXX/libs/pkg/container"
	"context"
	"{{.HelperPackage}}"
	{{range $val := .Imports}}"{{$val}}"
	{{end}}
)
	`

	StructDefineTemplate = `

func Register(mid ...func(*gin.Context)) {
	api.RegisterHttpRouter(New{{.InterfaceName}}Wrapper(mid))
}

type {{.InterfaceName}}Wrapper struct {
	handler *{{.InterfaceName}}Imp
	rootPath string
	middleWares []func(*gin.Context)
}

func New{{.InterfaceName}}Wrapper(mid []func(*gin.Context)) *{{.InterfaceName}}Wrapper {
	out := &{{.InterfaceName}}Wrapper {
		rootPath: "{{.RootPath}}",
		handler: New{{.InterfaceName}}Imp(),
		middleWares: mid,
	}
	err := container.Fill(out)
	if err != nil {
		panic(err)
	}
	return out
}

func (w *{{.InterfaceName}}Wrapper) Use(e *gin.Engine) {
	{{range $p:=.Parsers}}
	{{if $p.HasRequestMapping}}e.{{$p.RequestMapping.Method}}(w.rootPath+"{{$p.RequestMapping.Path}}", w.{{$p.MethodName}}){{end}}{{end}}
}

	`

	ImpStructDefineTemplate = `
type {{.InterfaceName}}Imp struct { {{range $service:=.Services}}
	{{if ne $service.Name ""}}{{$service.Name}}{{else}}{{$service.Type}}{{end}} {{if $service.IsPointer}}*{{end}}{{if ne $service.Package ""}}{{$service.Package}}.{{end}}{{$service.Type}} {{.ContainerTag}}{{end}}
	ctx context.Context
}

func New{{.InterfaceName}}Imp() *{{.InterfaceName}}Imp {
	out := &{{.InterfaceName}}Imp{
		ctx: context.Background(),
	}
	err := container.Fill(out)
	if err != nil {
		panic(err)
	}
	return out
}

func (imp *{{.InterfaceName}}Imp) WithContext(ctx context.Context) *{{.InterfaceName}}Imp {
	out := *imp
	{{range $service:=.Services}}
	out.{{if ne $service.Name ""}}{{$service.Name}}{{else}}{{$service.Type}}{{end}} = imp.{{if ne $service.Name ""}}{{$service.Name}}{{else}}{{$service.Type}}{{end}}.WithContext(ctx){{end}}
	out.ctx = ctx
	return &out
}
	
	`

	ImpFuncTemplate = `
func (imp *{{.InterfaceName}}Imp) {{.MethodName}}({{.GetParamInTmpl}}) ({{.GetResultsInTmpl}}) {
	//TODO:

}
	`

	WrapperFuncTemplate = `
func (w *{{.InterfaceName}}Wrapper) {{.MethodName}}(c *gin.Context) {
	for _, mid := range w.middleWares {
		mid(c)
		if c.IsAborted() {
			return
		}
	}

	var _tmp string
	_ = _tmp
	var err error
	{{range $val := .Params}} 
	var {{$val.Name}} {{if $val.IsPointer}}= new({{end}}{{if ne $val.Package ""}}{{$val.Package}}.{{end}}{{$val.Type}}{{if $val.IsPointer}}){{end}}{{end}}
	{{range $val:= .PathVariables}}
	_tmp = c.GetParam("{{$val.Name}}")
	if _tmp != "" {
		err = helper.BindStringToObject(_tmp, {{if not $val.Param.IsPointer}}&{{end}}{{$val.Param.Name}})
		if err != nil {
			c.JSON(200, 
				model.NewResponse(model.WithError(errors.Wrap(errorcode.ErrParameterInvalid, "path variable: {{$val.Name}}"))))
			return 
		}
	}
	{{end}}{{range $val:= .RequestParams}}
	_tmp = c.Query("{{$val.Name}}")
	{{if $val.Required}}if _tmp == "" {
		c.JSON(200, 
			model.NewResponse(model.WithError(errors.Wrap(errorcode.ErrParameterInvalid, "request param {{$val.Name}} is required"))))
		return
	}{{end}}
	if _tmp != "" {
		err = helper.BindStringToObject(_tmp, {{if not $val.Param.IsPointer}}&{{end}}{{$val.Param.Name}})
		if err != nil {
			c.JSON(200, 
				model.NewResponse(model.WithError(errors.Wrap(errorcode.ErrParameterInvalid, "request param {{$val.Name}}"))))
			return 
		}
	}
	{{end}}{{if .HasURIBinding}}
	if err = c.ShouldBindUri({{if not .URIBinding.IsPointer}}&{{end}}{{.URIBinding.Name}}); err != nil {
		c.JSON(200, 
			model.NewResponse(model.WithError(errors.Wrap(errorcode.ErrParameterInvalid, err.Error()))))
		return
	}
	{{end}}{{if .HasBodyBinding}}
	if err = c.ShouldBindJSON({{if not .BodyBinding.IsPointer}}&{{end}}{{.BodyBinding.Name}}); err != nil {
		c.JSON(200, 
			model.NewResponse(model.WithError(errors.Wrap(errorcode.ErrParameterInvalid, err.Error()))))
		return
	}
	{{end}}{{if .HasParamBinding}}
	if err = c.ShouldBindQuery({{if not .ParamBinding.IsPointer}}&{{end}}{{.ParamBinding.Name}}); err != nil {
		c.JSON(200, 
			model.NewResponse(model.WithError(errors.Wrap(errorcode.ErrParameterInvalid, err.Error()))))
		return
	}
	{{end}}
	
	ctx := c.Request.Context()
	handler := w.handler.WithContext(ctx)
	{{if .HasResponseData}}res, {{end}}err {{if .HasResponseData}}:{{end}}= handler.{{.MethodName}}({{.GetParamInFunc}})
	if err != nil {
		c.JSON(200, 
			model.NewResponse(model.WithError(err)))
		return
	}
	c.JSON(200, model.NewResponse(model.WithData({{if .HasResponseData}}res{{else}}nil{{end}})))
}
	`

	UserDefinedMethodTemplate = `
func (d *{{.StructName}}) {{.MethodName}}({{.GetParamInTmpl}})({{.GetResultsInTmpl}}) {
	{{if .HasSqlData}}params := map[string]interface{} { {{range $index,$data:= .SqlData}}
		"{{$data.Name}}": {{$data.Value}}, {{end}}
	}
	{{end}}{{if .HasNeedGenerateSql}}var generateSQL string {{range $line:=.SqlTmpList}}{{$line}}
	{{end}}{{end}}{{if.HasWhereConditions}}var whereConditions string {{range $line:=.GetWhereConditionTmp}}{{$line}}
	{{end}}{{end}}{{if .HasNeedNewResult}}{{.ResultData.Name}} = {{if .ResultData.IsMap}}make{{else}}new{{end}}({{if ne .ResultData.Package ""}}{{.ResultData.Package}}.{{end}}{{.ResultData.Type}}){{end}}
	{{if or .HasResultRowsAffected .HasResultError}}executeSQL:{{else}}_{{end}}= d.DB().{{.GetGORMChainTmp}}{{if .HasResultData}}.{{.GormRunMethodName}}({{if .HasGotPoint}}&{{end}}{{.ResultData.Name}}){{end}}
	{{if .HasResultRowsAffected}}rowsAffected = executeSQL.RowsAffected
	{{end}}{{if .HasResultError}}{{.ResultErrorName}} = executeSQL.Error
	{{end}}return
}
	`
	PageMethodTemplate = `

	`
)
